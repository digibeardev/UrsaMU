<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: exec.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: exec.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { matchExit, move } = require("./movement");
const parser = require("./parser");
const { find } = require("lodash");

module.exports = mush => {
  /**
   * Evaluate an input stream from the user for commands.
   * @param {Socket} socket The socket connection envoking the command
   * @param {String} string The raw input text from the socket.
   * @param {Object} scope  The variable scope for the command.
   */

  mush.exec = (socket, string, scope) => {
    let ran = false;

    // Timestamp the socket so we can track idle time.
    socket.timestamp = new Date().getTime() / 1000;

    // We only need to search for channels if the socket is actually
    // logged in.
    if (socket.id) {
      const enactor = mush.db.id(socket.id);
      // We need to split the input string, and try and match it to
      // any channel definitions.
      let [alias, ...rest] = string.split(" ");
      const chan = find(enactor.channels, { alias });
      if (
        (chan &amp;&amp; chan.status) ||
        (chan &amp;&amp;
          rest
            .join(" ")
            .toLowerCase()
            .trim() === "on")
      ) {
        string = string.replace("\r\n", "\n");

        let msg = "";
        if (rest.join(" ")[0] === ":") {
          msg += `${
            enactor.moniker ? enactor.moniker : enactor.name
          } ${rest.join(" ").slice(1)}`;
        } else if (rest.join(" ")[0] === ";") {
          msg += `${
            enactor.moniker ? enactor.moniker : enactor.name
          }${rest.join(" ").slice(1)}`;
        } else {
          rest = rest
            .join(" ")
            .toLowerCase()
            .trim();
          if (rest === "off") {
            mush.emitter.emit(
              "channel",
              mush.channels.get(chan.name),
              `${enactor.name} has left the channel.`
            );
            const index = enactor.channels.indexOf(chan);
            enactor.channels.splice(index, 1);

            // turn the channel off
            chan.status = false;
            enactor.channels.push(chan);
            return (ran = true);
          } else if (rest === "on") {
            const index = enactor.channels.indexOf(chan);
            enactor.channels.splice(index, 1);

            // turn the channel on
            chan.status = true;
            enactor.channels.push(chan);
            mush.emitter.emit(
              "channel",
              mush.channels.get(chan.name),
              `${enactor.name} has joined the channel.`
            );
            return (ran = true);
          } else {
            msg += `${
              enactor.moniker ? enactor.moniker : enactor.name
            } says "${rest.join(" ").trim()}"`;
          }
        }
        const channel = mush.channels.get(chan.name);
        mush.emitter.emit("channel", channel, msg.trim());
        ran = true;
      } else if (chan &amp;&amp; !chan.status) {
        mush.broadcast.send(socket, "You can't talk on that channel.");
        return (ran = true);
      }
    }

    // Cycle through the commands on the command object looking for a
    //  match in the users input string if no matching exit was found.
    if (!ran) {
      for (const command of mush.cmds.values()) {
        const { pattern, run, restriction } = command;
        const match = string.match(pattern);
        const obj = mush.flags.hasFlags(mush.db.id(socket.id), restriction);

        // If there's a match and the enactor passes the flag restriction of
        // the command or there's no restriction set, try to run the command.
        if ((match &amp;&amp; obj) || (match &amp;&amp; !restriction)) {
          // Try/Catch block just in case the command doesn't
          // go through, there's an error, or if the command
          // just straight doesn't exist.
          try {
            ran = true;
            return run(socket, match, scope);
          } catch (error) {
            return mush.broadcast.error(socket, error);
          }
        }
      }

      const enactor = mush.db.id(socket.id);
      const curRoom = mush.db.id(enactor.location);

      // Check to see if an exit name was enetered.
      const exit = matchExit(curRoom, string);
      if (exit &amp;&amp; !ran) {
        // Exit match was made.
        ran = true;
        move(socket, exit);
        mush.exe(socket, "look", []);
      }
    }

    if (!ran &amp;&amp; socket.id) mush.broadcast.huh(socket);
  };
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Attributes.html">Attributes</a></li><li><a href="Broadcast.html">Broadcast</a></li><li><a href="Flags.html">Flags</a></li><li><a href="Log.html">Log</a></li><li><a href="module.exports.html">exports</a></li><li><a href="Parser.html">Parser</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Fri Aug 30 2019 09:30:10 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
