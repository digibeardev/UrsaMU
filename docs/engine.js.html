<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: engine.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: engine.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const parser = require("./parser");
const emitter = require("./emitter");
const broadcast = require("./broadcast");
const db = require("./database");
const flags = require("./flags");
const config = require("./config");
const queue = require("./queues");
const { VM } = require("vm2");
const { find } = require("lodash");
const help = require("./helpsys");
const grid = require("./grid");
const attrs = require("./attributes");
const useraccts = require("./userAccts");
const channels = require("./channels");
const { log, sha256 } = require("./utilities");
const move = require("./movement");
/**
 * new engine()
 */
module.exports = class UrsaMu {
  constructor(options = {}) {
    const { plugins } = options;
    this.attrs = attrs;
    this.move = move;
    this.accounts = useraccts;
    this.help = help;
    this.grid = grid;
    this.parser = parser;
    this.broadcast = broadcast;
    this.emitter = emitter;
    this.cmds = new Map();
    this.txt = new Map();
    this.scope = {};
    this.log = log;
    this.db = db;
    this.find = find;
    this.flags = flags;
    this.queues = queue;
    this.config = config;
    this.plugins = plugins;
    this.VM = VM;
    this.sha256 = sha256;
    this.channels = channels;

    // Initialize in-game functionality.
    this.init();
  }

  /**
   * Init() holds startup event handlers and listeners for
   * the MUSH
   */
  init() {
    // If there isn't a grid set, UrsaMU will generate a starting
    // room and update the config settings to start all new players
    // there.  This starting room can be changed maually later.
    let room;
    const rooms = this.db.find({ type: "room" });
    if (rooms.length &lt;= 0) {
      this.log.warning("No Grid found.");
      room = this.db.insert({ name: "Limbo", type: "room" });
    }
    if (room) {
      this.log.success("Limbo succesfully dug.", 2);
      this.config.set("startingRoom", room.id);
    }

    try {
      require("./commands")(this);
      this.log.success("Commands loaded.");
    } catch (error) {
      this.log.error(`Unable to load commands. Error: ${error}`);
    }

    try {
      require("../text")(this);
      this.log.success("Text files loaded.");
    } catch (error) {
      this.log.error(`Unable to load text files. Error: ${error}`);
    }

    try {
      require("./exec")(this);
      this.log.success("Command parser loaded.");
    } catch (error) {
      this.log.error(`Unable to load command parser. Error: ${error}`);
    }

    require("./gameTimers")(this);

    // Clear all of the connected flags incase the server didn't go down clean.
    this.db.db
      .filter(entry => entry.type === "player")
      .forEach(entry => {
        this.flags.set(entry, "!connected");
      });

    this.db.save();

    // Run plugins if present.
    if (this.plugins) {
      this.plugin(this.plugins);
    }

    // Check for server events!
    this.emitter.on("connected", socket => {
      const enactor = this.db.id(socket.id);
      const curRoom = this.db.id(enactor.location);

      this.broadcast.sendList(
        socket,
        curRoom.contents,
        `${enactor.name} has connected.`,
        "connected"
      );
    });

    this.emitter.on("disconnected", socket => {
      const enactor = this.db.id(socket.id);
      const curRoom = this.db.id(enactor.location);
      this.broadcast.sendList(
        socket,
        curRoom.contents,
        `${enactor.name} has disconnected.`,
        "connected"
      );
    });

    this.emitter.on("channel", (chan, msg) => {
      this.queues.sockets.forEach(socket => {
        const target = this.db.id(socket.id);

        // loop through each channel, and see if there's a match.
        for (const channel of target.channels) {
          if (channel.name == chan.name &amp;&amp; channel.status) {
            let header = "";
            header += chan.moniker ? chan.moniker : `%ch&lt;${chan.name}>%cn`;

            try {
              this.broadcast.send(socket, `${header} ${channel.title} ${msg}`);
            } catch {}
          }
        }
      });
    });
  }

  /**
   * Force a player bit to execute a command
   * @param {Object} socket The socket of the enactor
   * @param {*} command The command to be executed
   * @param {*} args Any special arguments to pass along with the command
   */
  exe(socket, command, args = []) {
    try {
      return this.cmds.get(command).run(socket, args, this.scope);
    } catch (error) {
      throw error;
    }
  }

  // Check for plugins
  plugin(plugins) {
    // if plugins is an array, process the array.
    if (Array.isArray(plugins)) {
      plugins.forEach(plugin => {
        try {
          require(`../plugins/${plugin}`)(this);
          this.log.success(`Plugin installed: ${plugin}.`);
        } catch (error) {
          this.log.error(`Could not import plugin: ${plugin}`);
          this.log.error(`${error.stack}`);
        }
      });

      // If it's a string, process the string.
    } else if (typeof plugins === "string") {
      try {
        require("../plugins/" + plugins)(this);
      } catch (error) {
        this.log.error(`Could not import plugin: ${plugins}`);
        this.log.error(`${error.stack}`);
      }

      // Else it's not a format the plugin system can read.
    } else {
      this.logs.error(`Unable to read plugin: ${plugins}.`);
    }
  }

  /**
   * Show DBref and flag shorthand if looker has proper
   * permissions and/or ownership.
   * @param {DBO} en The enactor
   * @param {DBO} tar The target
   * @param {Boolean} override Don't show fancy header when
   * enactor is inside target.
   */
  name(en, tar, override = false) {
    // Make sure the enactor has permission to modify the target.
    // if so show dbref and flag codes, etc. Extra admin stuff.
    const objName = this.flags.canEdit(en, tar)
      ? `${tar.name}${this.flags.flagCodes(tar)}`
      : tar.name;

    return en.location === tar.id &amp;&amp; !override
      ? `[center(%ch%cr&lt;&lt;%cn %ch%0 %cr>>%cn,78,%cr-%cn)]`
      : objName;
  }
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Attributes.html">Attributes</a></li><li><a href="Broadcast.html">Broadcast</a></li><li><a href="Flags.html">Flags</a></li><li><a href="Log.html">Log</a></li><li><a href="module.exports.html">exports</a></li><li><a href="Parser.html">Parser</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Fri Aug 30 2019 09:30:10 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
